{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Simons Observatory Conda Tools","text":"<p>This git repository contains scripts to help with:</p> <ul> <li> <p>Installing a conda base system (optional)</p> </li> <li> <p>Creating a conda environment with a well-defined set of conda and pip packages</p> </li> <li> <p>Building a few legacy compiled packages into this environment</p> </li> <li> <p>Creating a versioned modulefile for loading the environment</p> </li> </ul> <p>The documentation also covers different user scenarios for loading and customizing a pre-installed environment.</p>"},{"location":"automate/","title":"Automating the Install","text":"<p>The general process of automating the install proceeds like this:</p> <ol> <li> <p>A cron job (or similar) runs periodically and launches a script which examines current tags of soconda and finds the latest one. It looks at the installation directory and determines whether this tag has been installed. If not, it runs an installation wrapper script for the current system.</p> </li> <li> <p>The wrapper script has hard-coded paths to the various locations and also knows how to build the version string to use. This script calls the <code>soconda.sh</code> script to install the latest tag.</p> </li> <li> <p>If a new tag was installed, a message is posted via slack hook to one of the Simons Observatory slack channels.</p> </li> </ol>"},{"location":"automate/#example-perlmutter-at-nersc","title":"Example:  Perlmutter at NERSC","text":"<p>In the <code>deploy</code> subdirectory are the relevant files. The perlmutter install wrapper script is in <code>install_perlmutter.sh</code>. The tag checking script run by the cron job is in <code>install_nersc_tag.sh</code>, and the example lines in the scron tab are in <code>scron_check_tag.slurm</code>.</p>"},{"location":"dev/","title":"Developer Notes","text":"<p>This section covers steps needed when maintaining the <code>soconda</code> tools.</p>"},{"location":"dev/#releases","title":"Releases","text":"<p>After updating the versions of included packages, it is a good idea to make a new release so that a new environment is built and deployed. After all outstanding changes are merged to <code>main</code>, go to the github page for this repository and click on the <code>Actions</code> tab. Trigger the <code>Test Build</code> workflow. This will take an hour or so to run. Assuming it all works, create a new release with some notes about what was updated. Cron jobs running on our computing centers will check for new tags and build them if found.</p>"},{"location":"dev/#changing-the-build-configuration","title":"Changing the Build Configuration","text":"<p>The <code>config/common.txt</code> file contains conda packages that should be installed on all systems. There are subdirectories under <code>config</code> for each unique machine / build configuration. Here we discuss the contents of each of these subdirectories.</p>"},{"location":"dev/#environment-setup","title":"Environment Setup","text":"<p>There are two optional files which can be used to control how the environment is set up. After installation, an optional soconda modulefile is installed. You can add custom initialization lines to this module file by placing them in a file named:</p> <pre><code>config/&lt;name_of_config&gt;/module_init\n</code></pre> <p>The lines in this file should be compatible with whatever module flavor is used on the system. For example, if the system is using lmod, then this snippet should be lua commands. If the system is using TCL based modules, then this snippet should be tcl commands.</p> <p>When building / installing soconda, you can place arbitrary shell commands in a file named:</p> <pre><code>config/&lt;name_of_config&gt;/build_env.sh\n</code></pre> <p>This file will be sourced by the <code>soconda.sh</code> script before starting. Note that these commands are only executed during the installation. For run time setup, put module commands in the <code>module_init</code> file.</p>"},{"location":"dev/#package-selection","title":"Package Selection","text":"<p>There are 3 files that control which packages are installed for a particular configuration (in addition to the conda-forge packages listed in <code>config/common.txt</code>). To specify packages (including the python version) to be installed from conda-forge, add those to:</p> <pre><code>config/&lt;name_of_config&gt;/packages_conda.txt\n</code></pre> <p>To control which conda packages should be built from the local recipes, add packages to:</p> <pre><code>config/&lt;name_of_config&gt;/packages_local.txt\n</code></pre> <p>And finally, to install packages with pip, add them to the file:</p> <pre><code>config/&lt;name_of_config&gt;/packages_pip.txt\n</code></pre> <p>Note that each of these pip packages is analyzed with <code>pipgrip</code> to find their dependencies and those dependencies are installed with conda if available. This reduces the number PyPI packages that end up in the final environment.</p>"},{"location":"dev/#post-install-steps","title":"Post-install Steps","text":"<p>An optional shell snippet can be specified at:</p> <pre><code>config/&lt;name_of_config&gt;/post_install.sh\n</code></pre> <p>And this file will be sourced in soconda.sh after the installation is complete, and while the installed environment is active. This file can contain arbitrary shell commands to do things like change permissions, override a package, etc. There are also 2 shell variables that can be modified in this file which control behavior at the end of soconda.sh:</p> <pre><code>install_module=yes\ninstall_jupyter_setup=yes\n</code></pre> <p>The first option controls whether to install the soconda modulefile. Enabling the second option will install a script that allows users to create a jupyter kernel file for the soconda stack.</p>"},{"location":"dev/#updating-bundled-recipes","title":"Updating Bundled Recipes","text":"<p>The conda recipes for bundled packages should be updated whenever upstream packages have new releases. This involves the following steps:</p> <ol> <li> <p>Update the version in the <code>meta.yaml</code> file of the package recipe.</p> </li> <li> <p>Update the download URL if needed.</p> </li> <li> <p>Compute the new sha256:</p> <p>curl -sL https://github.com/username/reponame/archive/vX.X.X.tar.gz | openssl sha256</p> </li> <li> <p>Copy the hash into the <code>meta.yaml</code> file.</p> </li> <li> <p>Ensure that the new version of the package does not have any updated dependencies or other constraints.</p> </li> </ol>"},{"location":"dev/#adding-new-package-recipes","title":"Adding New Package Recipes","text":"<p>This should not be needed very often, and will require some familiarity with conda recipes. Create a new directory for the recipe in the <code>pkgs</code> directory. Add a <code>meta.yaml</code> file, a <code>build.sh</code> file, and a copy of the package license. See the conda documentation and existing conda-forge feedstocks for extensive examples. You can load an existing soconda environment as a testbed and then test your new recipe with <code>conda build</code>. After you can build it independently, add it to the <code>packages_local.txt</code> file.</p>"},{"location":"install/","title":"Creating a Simons Observatory Environment","text":"<p>The install script takes options to specify the location of the base environment (if it is not already activated) and the name (or full path) of the environment to create. It also allows specifying a central location to install the modulefile:</p> <pre><code>./soconda.sh -h\n    Usage:  ./soconda.sh\n    [-c &lt;directory in config to use for options&gt;]\n    [-e &lt;environment, either name or full path&gt;]\n    [-b &lt;conda base install (if not activated)&gt;]\n    [-v &lt;version (git version used by default)&gt;]\n    [-m &lt;modulefile dir (default is &lt;env&gt;/modulefiles)&gt;]\n    [-i &lt;file with modulefile commands to load dependencies&gt; ]\n</code></pre> <p>NOTE</p> <p>Running the <code>soconda.sh</code> script will create log files in the current directory. Consider running the command from within a temporary build directory to avoid clutter.</p>"},{"location":"install/#base-conda-environment","title":"Base Conda Environment","text":"<p>If you already have a conda-forge or micromamba base environment, install <code>conda-build</code> and <code>conda-verify</code> package to base environment.</p> <pre><code>conda update -n base --yes --all conda\nconda install -n base --yes --all conda-build conda-verify\n</code></pre> <p>Also, you should consider setting the \"solver\" in the base environment to use <code>libmamba</code>. To use <code>libmamba</code> solver see this article. This will greatly speed up the dependency resolution calculation.</p> <p>For new installation run following script to install miniforge</p> <pre><code>./tools/bootstrap_base \"$HOME/miniforge3\"\n</code></pre> <p>This will intall conda to <code>$HOME/miniforge3</code> directory. It will set conda-forge as default channel and use <code>libmamba</code> as default solver. After the installation you need to re-login or start a new terminal to initialize conda.</p> <p>After installing an <code>soconda</code> environment below, you will not need this step since it is done by the generated modulefile.</p>"},{"location":"install/#special-note-on-mpi4py","title":"Special Note on mpi4py","text":"<p>By default, the conda package for mpi4py will be installed. This should work well for stand-alone workstations or single nodes. If you have a cluster with a customized MPI compiler, then set the <code>MPICC</code> environment variable to the MPI C compiler before running <code>soconda.sh</code>. That will cause the mpi4py package to be built using your system MPI compiler.</p>"},{"location":"install/#install-soconda","title":"Install soconda","text":""},{"location":"install/#example-local-system","title":"Example:  Local System","text":"<p>This installation could install <code>soconda</code> to your local computer and any cluster.</p> <p>Clone soconda repo</p> <pre><code>git clone git@github.com:simonsobs/soconda.git\ncd soconda\n</code></pre> <p>Run the <code>soconda.sh</code> script</p> <pre><code>export MAKEFLAGS='-j 4'\nbash soconda.sh -e soconda -c default\n</code></pre> <p>This will create a new environment <code>soconda_xxx.x.x</code> with version number as suffix using <code>default</code> configuration. More details on configuration. (The <code>MAKEFLAGS</code> doesn't seem to have any effect.) If you want to specify a conda base directory add <code>-b \"$HOME/miniforge3\"</code> argument to <code>soconda.sh</code>.</p> <p>You could find out the name of new created environment with</p> <pre><code>conda env list\n</code></pre> <p>Then you can now activate the environment with</p> <pre><code>conda activate soconda_xxx.x.x\n</code></pre> <p>If running on a Linux desktop that uses wayland, you also need to install the <code>qt-wayland</code> package</p> <pre><code>conda install qt-wayland\n</code></pre> <p>If running on server, start jupyterlab listening on port <code>12345</code> with command</p> <pre><code>cd /path/to/project\nnohup jupyter-lab --no-browser --port=12345 &amp;&gt; jupyter.log &amp;\n</code></pre> <p>To list current running jupyter server:</p> <pre><code>jupyter server list\n</code></pre> <p>To connect to jupyterlab running on server, start SSH tunnel from your laptop/desktop:</p> <pre><code>ssh -N -L 12345:localhost:12345 server_domain_or_ip\n</code></pre> <p>Then you can connect to jupyterlab with link provided by command <code>jupyter server list</code>.</p> <p>To stop jupyterlab listenging on port 12345:</p> <pre><code>jupyter server stop 12345\n</code></pre>"},{"location":"install/#example-nersc","title":"Example:  NERSC","text":"<p>At NERSC, the default provided python is from Anaconda, and does not work well for our needs. Instead, we have a conda-forge base system installed in our project software directory:</p> <pre><code>source /global/common/software/sobs/perlmutter/conda_base/etc/profile.d/conda.sh\nconda activate base\n</code></pre> <p>Now we can either install a shared software environment or use this base environment to build a conda environment in a personal directory. If you are installing to a shared software environment, you should do that as the project account and follow a specific naming convention which is beyond the scope of this document. If you wanted to install these tools to your home directory you could do:</p> <pre><code>mkdir -p ~/conda_envs\n./soconda.sh -e ~/conda_envs/soconda -m ~/conda_envs/modulefiles\n</code></pre> <p>And then load the module:</p> <pre><code>module use ~/conda_envs/modulefiles\nmodule avail\nmodule load soconda/XXXXXX\n</code></pre>"},{"location":"install/#running-tests","title":"Running Tests","text":"<p>After loading an <code>soconda</code> environment, you can run some tests with:</p> <pre><code>./run_tests.sh\n</code></pre>"},{"location":"install/#installing-a-jupyter-kernel-for-external-jupyter-server","title":"Installing a Jupyter Kernel for external Jupyter server","text":"<p>After loading an soconda module or activate socond conda environment the first time, you can run (once) the included script:</p> <pre><code>soconda_jupyter.sh\n</code></pre> <p>This will install a kernel file to <code>~/.local/share/jupyter/kernels/soconda-xxxxx</code> so that external jupyter server knows how to launch a kernel using this python stack.</p>"},{"location":"install/#customizing-an-environment","title":"Customizing an Environment","text":"<p>When running <code>soconda.sh</code>, the system configuration to use can be specified with the <code>-c</code> option. This should be the name of the configuration subdirectory with the \"config\" top-level directory. If not specified, the \"default\" config is used. If you want to dramatically change the package versions / content of an <code>soconda</code> stack, just load the existing <code>base</code> conda environment, copy one of the configs to a new name and edit the three lists of packages (<code>packages_[conda|pip|local].txt</code>) to exclude certain packages or add extras. Then install it as usual.</p>"},{"location":"install/#deleting-an-environment","title":"Deleting an Environment","text":"<p>The <code>soconda</code> environments are self contained and you can delete them by running command <code>conda remove --name envname --all</code> or <code>conda remove -p /base_dir/envs/name --all</code>. Or directly removing the <code>&lt;base dir&gt;/envs/&lt;name of env&gt;</code> directory. You can optionally delete the modulefile and the versioned pip local directory in your home directory. If you installed a jupyter kernel, remove kernel file in <code>~/.local/share/jupyter/kernels/</code> with matching soconda version. If you have multiple soconda environment and deleted wrong kernel file, you can always recreate it.</p>"},{"location":"install/#advanced-details","title":"Advanced Details","text":"<p>The compiled packages assume the use of the conda compilers for consistency with the libraries installed through conda. If you want to change those compilers you can remove the <code>compilers</code> conda package and manually set the <code>CC</code>, <code>CXX</code>, and <code>FC</code> environment variables. Full warning that this may cause problems with threading interfaces, thread pinning, etc, when building packages that use OpenMP.</p>"},{"location":"install/#pixell","title":"Pixell","text":"<p>We currently build pixell from source with the conda compilers for consistency, rather than installing the wheel.</p>"},{"location":"install/#libactpol-moby2","title":"Libactpol / Moby2","text":"<p>There are three conda recipes for <code>libactpol_deps</code>, <code>libactpol</code>, and <code>moby2</code>. These are using git hashes that are either the latest or a branch / version recommended for S.O. use.</p>"},{"location":"install/#so3g","title":"So3g","text":"<p>This package is currently installed from the wheel, but the conda package is being tested (using boost from conda-forge).</p>"},{"location":"install/#toast","title":"TOAST","text":"<p>This package is currently built from source by default, with dependencies installed through conda. When toast-3.0 arrives in the conda-forge toast feedstock, it should be added back to <code>packages_conda.txt</code>. It should also work to install the python wheel package by commenting out the toast entry in <code>packages_local.txt</code> and adding it to <code>packages_pip.txt</code>.</p>"},{"location":"usage/","title":"Using an Existing Environment","text":"<p>If you are just using an already-created environment, you can follow instructions on the Simons Observatory project confluence site (see the Data Management pages on Computing Infrastructure) about where to find the installation for a particular system. After loading an environment, there are a several ways to customize things.</p>"},{"location":"usage/#overriding-a-few-packages","title":"Overriding a Few Packages","text":"<p>Each <code>soconda</code> modulefile sets the user directory (for <code>pip install --user</code>) to be in a versioned location in your home directory. If you want to use a different / newer version of <code>sotodlib</code> (for example), then you can just do:</p> <pre><code>$&gt; pip install --user https://github.com/simonsobs/sotodlib/archive/master.tar.gz\n</code></pre> <p>If you swap to a different <code>soconda</code> environment, your user package install directory will also switch.</p>"},{"location":"usage/#more-extensive-customization","title":"More Extensive Customization","text":"<p>One benefit of an <code>soconda</code> environment is that it also contains conda packages built for some legacy compiled tools. If you want to keep those, but dramatically change which other conda packages are installed, you can first create a new personal environment while cloning an existing one:</p> <pre><code>$&gt; conda create --clone soconda_20230809_1.0.0 -p /path/to/my/env\n</code></pre> <p>Then activate your new environment and conda install whatever you like:</p> <pre><code>$&gt; conda activate /path/to/my/env\n$&gt; conda install foo bar blat\n</code></pre> <p>Note that your pip user directory will still be set to the location created by the original upstream module, and you can also \"<code>pip install --user</code>\" additional packages to go with your custom conda environment.</p>"},{"location":"usage/#something-else","title":"Something Else","text":"<p>You can also just load a conda base environment on a particular system and then read the next section of this document to install your own environment.</p>"}]}